"""
Написать два алгоритма нахождения i-го по счёту простого числа.
Без использования «Решета Эратосфена»;
Используя алгоритм «Решето Эратосфена»

Подсказка:
Сравните алгоритмы по времени на разных порядковых номерах чисел:
10, 100, 1000
Опишите результаты, сделайте выводы, где и какой алгоритм эффективнее
Подумайте и по возможности определите сложность каждого алгоритма

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""


from math import ceil, log1p
import timeit


def test_not_sieve():
    """
    Довольно непросто оказалось придумать вариант заведомо хуже, чем с
    использованием решета. Смею надеяться, что, не знай я о нём, то всё
    равно в своём решении пришёл бы к чему-то подобному.
    :return: None
    """
    def not_sieve(var_list, prime):
        """
        Сложность - квадратичная, из-за вложенного цикла. С ростом значения
        элемента во внешнем цикле for, будет увеличиваться количество
        перебираемых для него элементов вложенного цикла. Что вполне походит на
        степенную зависимость с натуральным показателем (другой вопрос,
        действительно ли это будет второая степетнь)
        :param var_list: list of int
        :param prime: int
        :return: int
        """
        simple = [2]
        for i in var_list[1:]:
            buf_list = var_list[:var_list.index(i)]
            counter = 0
            for div_el in buf_list:
                if i % div_el != 0:
                    counter += 1
                if counter == len(buf_list):
                    simple.append(i)
                    if len(simple) >= prime:
                        return simple[prime - 1]

    number_of_prime = 10000
    # Здесь и для второго варианта долго выбирал, какой длины сделать список,
    # чтобы в него точно попало запрашиваемое простое число. Как и часть моих
    # однокурсников, обратился к теореме распределения просых чисел. Путём
    # подбора разных вариантов, в итоге согласился с предложенным в нашем
    # групповом чате вариантом. До проверенного мною 20000 простого числа он
    # выдвавл наиболее близкие к искомому значению, а значит длина начального
    # списка не была сильно больше необходимого, что, естественно, влияет на
    # время выполнения кода.
    start_list = list(range(2, ceil(number_of_prime *
                                    log1p(2 * number_of_prime) +
                                    number_of_prime)))
    print(not_sieve(start_list, number_of_prime))


def test_sieve():
    """
    Мой изначальный вариант, посторенный на рекурсии, благополучно начал
    вылетать на больших значениях с соответствующей ошибкой глубины рекурсии.
    Пришлось переделывать через while True.
    :return: None
    """
    def sieve(var_list, prime):
        """
        Сложность, как отмечалось ранее на уроках - логарифмическая. Немного
        сбивает с толку наличие вложенного цикла. Но действие алгоритма таково:
        цикл while перезапускает цикл for, и список для последнего становится
        короче с каждой итерацией первого. Причём укорачивается он тоже на всё
        возрастающее количество элементов с каждой итерацией while. Что вполне
        похоже на логарифмическую зависимость (пусть и по неизвестному
        основанию).
        :param var_list: list of int
        :param prime: int
        :return: int
        """
        simple = []
        while True:
            for i in var_list[1: len(var_list)]:
                if i % var_list[0] == 0:
                    var_list.remove(i)
            # Сразу решаем 2 задачи - с каждой итерацией уменьшаем проверяемый
            # список и увеличиваем список найденных простых чисел.
            simple.append(var_list.pop(0))
            if len(simple) >= prime:
                return simple[prime - 1]

    number_of_prime = 10000
    start_list = list(range(2, ceil(number_of_prime *
                                    log1p(2 * number_of_prime) +
                                    number_of_prime)))
    print(sieve(start_list, number_of_prime))


print(
    timeit.timeit(
        "test_not_sieve()",
        setup="from __main__ import test_not_sieve",
        number=1))
print(
    timeit.timeit(
        "test_sieve()",
        setup="from __main__ import test_sieve",
        number=1))

"""
10е простое число - 29, было найдено алгоритмом без решета за 190 мкс, с 
решетом - за 60 мкс. Разница в 3,17 раз.
100е простое число - 541, было найдено алгоритмом без решета за 52 мс, с 
решетом - за 3 мс. Разница в 17,33 раз.
1000е простое число - 7919, было найдено алгоритмом без решета за 10,75 сек, с 
решетом - за 0,44 сек. Разница в 24,43 раз.
Логарифмическая функция, как вполне очевидно, с ростом искомого 
числа значительно выполняется всё быстрее степенной с натуральным показателем. 
"""